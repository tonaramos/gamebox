<!DOCTYPE html>
<html lang="en">
  <head>
    <meta content="text/html;charset=utf-8" http-equiv="Content-Type">
    <meta content="utf-8" http-equiv="encoding">
  </head>
  <body>
    <canvas id="gameCanvas" width="800" height="600"></canvas>

    <script>
      // Everything in here is Javascript!
      const ballDiameter = 10;
      let ballX = 75;
      let ballSpeedX = 5;

      let ballY = 5;
      let ballSpeedY = 7;

      const brick_width = 100;
      const brick_height = 50;
      const brick_count = 10;
      let brickGrid = new Array(brick_count); 

      let canvas;
      let canvasContext;

      let mouseX;
      let mouseY;

      const paddle_width = 100;
      const paddle_height = 10;
      const paddle_distance_from_edge = 60;
      let paddleX = (800/2)-(paddle_width/2);

      window.onload = () => {                               // ===> window.onload() gets call right after the html document loads
        canvas = document.getElementById('gameCanvas');     //get the node with id gameCanvas
        canvasContext = canvas.getContext('2d');            //returns an object that provides methods and properties for drawing on the canvas
        
        const framesPerSecond = 30;
        setInterval(updateAll, 1000/framesPerSecond);

        canvas.addEventListener('mousemove', updateMousePosition);

        brickReset();
      }
      
      const updateAll = () => {
        moveAll();
        drawAll();
      }
      const ballReset = () => {
        ballX = canvas.width/2;
        ballY = canvas.height/2;
      }

      const brickReset = () => {
        for (let i=0;i<brick_count; i++) {
          if (Math.random()<0.5) {
            brickGrid[i] = true;
          } else {
            brickGrid[i] = false
          }  // end of else (random check)
        }   //end of each brick
      }   // end of brick set for loop

      const updateMousePosition = (event) => {
        const rect = canvas.getBoundingClientRect();
        const root = document.documentElement;
        
        mouseX = event.clientX - rect.left - root.scrollLeft;     // mouseX position - distance on the canvas left side - how much has the client scrolled to the side
        mouseY = event.clientY - rect.top - root.scrollTop;
        paddleX = mouseX - paddle_width/2;                                               // updates the x cordinate of the paddle
      }

      const moveAll = () => {
          ballX += ballSpeedX;
          ballY += ballSpeedY;
          // console.log('the x val->', ballX);

          if (ballX > canvas.width) {     //right
            ballSpeedX *= -1;
          }
          if (ballX < 0) {                //left
            ballSpeedX *= -1;
          }

          if (ballY > canvas.height) {    //bottom edge
            // ballSpeedY *= -1;
            ballReset();
          }
          if (ballY < 0) {                //top edge
            ballSpeedY *= -1;
          }
 
          // check if the ball has Overlapped the paddle
          const paddleTopEdgeY = canvas.height - paddle_distance_from_edge;
          const paddleBottomEdgeY = paddleTopEdgeY + paddle_height;
          const paddleLeftEdgeX = paddleX;
          const paddleRightEdgeX = paddleLeftEdgeX + paddle_width;
          if ( ballY > paddleTopEdgeY - ballDiameter/2 &&    // bellow top of the paddle
            ballY < paddleBottomEdgeY - ballDiameter/2 &&    // above bottom of paddle
            ballX > paddleLeftEdgeX &&     // right of the left side of the paddle
            ballX < paddleRightEdgeX) {     // left fo the right side of the paddle
          
              ballSpeedY *= -1;

              const centerOfPaddleX = paddleX + paddle_width/2;
              const ballDistanceFromPaddleCenterX = ballX - centerOfPaddleX;
              ballSpeedX = ballDistanceFromPaddleCenterX*.2;
            }


        }

      const drawAll = () => {
          colorRect(0,0, canvas.width, canvas.height, "black"); // clear screen// Takes 4 args the otp left left corner and width and hight if the shape 
          colorCircle(ballX, ballY, ballDiameter, "white");               // draw ball
          colorRect(paddleX, canvas.height - paddle_distance_from_edge, paddle_width, paddle_height, 'white');
          drawBricks();
          colorText(mouseX + ',' + mouseY, mouseX, mouseY, 'yellow');
        }

      const colorRect = (topLeftX, topLeftY, boxWidth, boxHeight, fillColor) => {
        canvasContext.fillStyle = fillColor;
          canvasContext.fillRect(topLeftX, topLeftY, boxWidth, boxHeight);

      }
      
      const colorCircle = (centerX, centerY, radius, fillColor) => {
        canvasContext.fillStyle = fillColor;
          canvasContext.beginPath();
          canvasContext.arc(centerX, centerY, radius, 0, Math.PI*2, true);
          canvasContext.fill();
      }
      
      const drawBricks = () => {
        for  (let i=0; i<brickGrid.length; i++) {
          if (brickGrid[i]) {
          colorRect(brick_width*i,0, brick_width-2, brick_height, 'blue');  
          } 
        }
        
      }

      const colorText = (showWords, textX, textY, fillColor) => {
        canvasContext.fillStyle = fillColor;
        const positionX = textX > canvas.width -50 ? textX-40 : textX+10;
        const positionY = textY > canvas.height -30 ? textY-5 : textY+25;
        canvasContext.fillText(showWords, positionX, positionY);
      }

      console.log('Hello');
    </script>
  </body>
</html>
